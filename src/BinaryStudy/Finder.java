package BinaryStudy;

/**
 * Created by lsj on 17-4-15.
 * 数组A包含了0到n的所有整数，但其中缺失了一个。对于这个问题，我们设定限制，
 * 使得一次操作无法取得数组number里某个整数的完整内容。唯一的可用操作是询问数组中第i个元素的二进制的第j位(最低位为第0位)，该操作的时间复杂度为常数，请设计算法，在O(n)的时间内找到这个数。

 给定一个数组number，即所有剩下的数按从小到大排列的二进制各位的值，
 如A[0][1]表示剩下的第二个数二进制从低到高的第二位。同时给定一个int n，意义如题。请返回缺失的数。
 测试样例：

 [[0],[0,1]]

 返回：1
 思路:题目意思:
 题目用数组A的一行元素表示一个整数，即A[0]～A[n-1]分别代表n个整数。记A[m]表示整数a,
 则第m行的第x列表示a的二进制表示时从低到高的第x位。样例中A[0]为[0]，即第1位为0，
 表示整数0；A[1]=[0,1],即第1位为0，第2位为1，
 表示整数2，因此缺失了整数1。样例中如果有其他整数，如A[5],则应该为[1,0,1]，依次类推。
 */
public class Finder {
    public int findMissing(int[][] numbers, int n) {
        // write code here
        for(int i=0;i<n;i++){//首先考虑前面n-1个数
            if((i%2)!=numbers[i][0]){
                return numbers[i][0];
            }

        }
        return n;//如果前面m
    }
}